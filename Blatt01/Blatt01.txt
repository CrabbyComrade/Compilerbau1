Aufgabe 1:
    Der reguläre ausdruck " a   +   a   ( a   +   b ) ∗   a" beschreibt die Sprache L={ w ∈{a,b}∗ ∣ w beginnt mit mindestens einem a,w endet mit a}
Aufgabe 2:
    Regex:
        ^(V|v|p|P|[a-zA-Z]) [a-zA-Z0-9_]* [a-zA-Z0-9]$
            ^(V|v|p|P|[a-zA-Z])     : Anfangszeichen v/V für Variablen, p/P für Parameter, jeder Buchstabe für alles andere (Streng genommen reicht [a-zA-Z] hier aus)
            [a-zA-Z0-9_]*           : Folgende Zeichen sind Buchstaben, Ziffern oder Unterstriche, beliebige Anzahl
            [a-zA-Z0-9]             : Letztes Zeichen ist Buchstabe oder Ziffer aber nie Unterstrich
        Beispiele : 
            variable_name_local -> v ist ein Buchstabe, ariable_nam besteht aus Buchstaben, Ziffern und Unterstrichen, e ist ein buchstabe und kein Unterstrich
            ParameterName7 -> P ist ein Buchstabe, arameterName besteht aus Buchstaben und Ziffern, 7 ist eine ziffer und kein Unterstrich
    
    Deterministische endliche Automat:
        Alphabet Σ = { a–z, A–Z, 0–9, _ }
        Zustände Q:
            q0          : kein Zeichen gelesen
            q1          : Startzeichen gelesen und gültig
            q2          : 2+ gültige Zeichen gelesen, letztes Zeichen kein _ (Wenn danach kein Zeichen kommt ist es gültig)
            q3          : 2+ gültige Zeichen gelesen, letztes Zeichen ist _ (Wenn danach kein Zeichen, ist es ungültig)
        Übergangsfunktion δ:
            Zustand             Eingabe             Nächster Zustand
            q0                  [a-zA-Z]            q1
            q0                  [0-9_]              q4
            q1                  [a-zA-Z0-9]         q2
            q1                  _                   q3
            q2                  [a-zA-Z0-9]         q2
            q2                  _                   q3
            q3                  [a-zA-Z0-9]         q2
            q3                  _                   q3
        Startzustand : q0
        Endzustände : q2, (vielleicht auch q3, allerdings ist das ja kein gültiger Endzustand)
        Beispiele : 
            variable_name_local : q0 -> v gelesen -> q1 -> a gelesen -> q2 -> r gelesen -> q2 -> [..] -> l gelesen -> q2
            ParameterName7      : q0 -> P gelesen -> q1 -> a gelesen -> q2 -> r gelesen -> q2 -> [..] -> 7 gelesen -> q2
    
    Grammatik:
        Nichtterminale N : N = {S, A, B, C}
        Terminale T : T =  { a–z, A–Z, 0–9, _ }
        Startsymbol = S
        Produktionen : (Sehr ähnlich zur Übergangsfunktion oben)
            S -> [a-zA-Z] A  (heisst : S kann ersetzt werden mit einem Terminal a-z und dem Zustand A)
            A -> [a-zA-Z0-9] B
            A -> _           C
            B -> [a-zA-Z0-9] B
            B -> _           C
            C -> [a-zA-Z0-9] B
            C -> _           C
            B -> ε (Heisst : nach B kann das Wort enden)
        Beispiele : 
            var :
                S -> v A
                A -> a B
                B -> r B
                B -> ε
            par :
                S -> p A
                A -> a B
                B -> r B
                B -> ε

Aufgabe 3: Gleitkommazahlen
    In Java : optionales Vorzeichen +-, Ganzzahliger Teil, optionaler Dezimalpunkt, optionale Nachkommastellen, optionaler Exponent eE mit Vorzeichen und Ziffern, optionales fFdD für double/float
        Regex : ^[+-]? (\d+(\.\d*)?|\.\d+)  ([eE][+-]\d+)? [fFdD]?$

        Deterministische endliche Automat:
            Alphabet Σ = { +, -, 0–9, . , e-d, E-D }
            Zustände Q:
                q0      : kein Zeichen gelesen
                q1      : Vorzeichen, '+' oder '-'
                q2      : Ganzzahliger Teil, 1+ Ziffern
                q3      : Dezimalpunkt '.'
                q4      : Nachkommastellen 1+ Ziffern
                q5      : Exponentzeichen 'e' oder 'E'
                q6      : Vorzeichen vom Exponenten '+' oder '-'
                q7      : Exponent-Ziffern, 1+ Ziffern nach Exponent
                q8      : Float/Double 'f', 'F', 'd', 'D'

            Übergangsfunktion δ:
                Zustand   Eingabe             Nächster Zustand
                q0        +, -                q1
                q0        0-9                 q2
                q0        .                   q3
                q1        0-9                 q2
                q1        .                   q3
                q2        0-9                 q2
                q2        .                   q4
                q2        e, E                q5
                q2        f, F, d, D          q8
                q3        0-9                 q4
                q4        0-9                 q4
                q4        e, E                q5
                q4        f, F, d, D          q8
                q5        +, -                q6
                q5        0-9                 q7
                q6        0-9                 q7
                q7        0-9                 q7
                q7        f, F, d, D          q8
            Startzustand : q0
            Endzustände : q2, q4, q7, q8

            Beispiele: 
                3.14e-10F :
                    q0 -> 3 gelesen -> q2
                    q2 -> . gelesen -> q3
                    q4 -> 1 gelesen -> q4
                    q4 -> 4 gelesen -> q4
                    q4 -> e gelesen -> q5
                    q5 -> - gelesen -> q6
                    q6 -> 1 gelesen -> q7
                    q7 -> 0 gelesen -> q7
                    q7 -> F gelesen -> q8

                -2.3f :
                    q0 -> - gelesen -> q1
                    q1 -> 2 gelesen -> q2
                    q2 -> . gelesen -> q3
                    q4 -> 3 gelesen -> q4
                    q4 -> f gelesen -> q8

        Grammatik :
            Nichtterminale N : N = { S, A, B, C, D, E, F, G, H }
            Terminale T : T = { +, -, 0–9, . , e-d, E-D }
            Startsymbol = S
            Produktionen :
                S -> [+|-] A
                A -> [0-9] B
                A -> . C 
                B -> [0-9] B   
                B -> ε 
                C -> [0-9] D 
                D -> e E         
                D -> ε       
                E -> [+|-] F     
                E -> F            
                F -> [0-9] F   
                F -> ε             
                G -> f        
                G -> F          
                G -> ε   

    In Python : kein fFdD am Ende, ansonsten gleich

Aufgabe 4 : Mailadressen
    ( a − z )+ @ ( a − z ) . ( a − z ) ungeeignet, weil:
        auch Grossbuchstaben A-Z enthalten sein können
        der name auch Zahlen, unterstriche und bindestriche enthalten kann
        das zweite und dritte (a-z) jeweils nur 1 Buchstaben erlauben also "a.b" statt "hsbi.com"
        domain muss nach dem punkt mind. 2 zeichen haben
    Verbesserung: ^[a-zA-Z0-9_-]+ @[a-zA-Z0-9-]+ \.[a-zA-Z]{2,}$
        [a-zA-Z0-9_-]+       : Name mit buchhstaben, zahlen etc.
        @[a-zA-Z0-9-]+       : Domain vor Punkt, buchstaben, Zahlen, bindestrich
        \.[a-zA-Z]{2,}$         : Domain nach punkt, nur buchstaben, 2 oder mehr

Aufgabe 6 :
        (a(b|c)*d?(a|b|c))+
        Beginnt mit A
        Dann b|c beliebig oft (Nichtterminale A führt auf sich selbst zurück)
        Potenziell ein d
        Dann a|b|c
        Da Potenziell von A zu B und von B zurück zu A, eine schleife also das ganze potenziell mehr als einmal
